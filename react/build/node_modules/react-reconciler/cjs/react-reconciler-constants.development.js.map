{"version":3,"file":"react-reconciler-constants.development.js","sources":["../../../../packages/react-reconciler/src/ReactFiberLane.old.js","../../../../packages/react-reconciler/src/ReactEventPriorities.old.js","../../../../packages/react-reconciler/src/ReactRootTags.js"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\r\nimport type {Transition} from './ReactFiberTracingMarkerComponent.old';\r\nimport type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.old';\r\n\r\n// TODO: Ideally these types would be opaque but that doesn't work well with\r\n// our reconciler fork infra, since these leak into non-reconciler packages.\r\n\r\nexport type Lanes = number;\r\nexport type Lane = number;\r\nexport type LaneMap<T> = Array<T>;\r\n\r\nimport {\r\n  enableSchedulingProfiler,\r\n  enableUpdaterTracking,\r\n  allowConcurrentByDefault,\r\n  enableTransitionTracing,\r\n} from 'shared/ReactFeatureFlags';\r\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook.old';\r\nimport {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';\r\nimport {clz32} from './clz32';\r\n\r\n// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\r\n// If those values are changed that package should be rebuilt and redeployed.\r\n\r\nexport const TotalLanes = 31;\r\n\r\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\r\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\r\n\r\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\r\n\r\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;\r\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;\r\n\r\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;\r\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;\r\n\r\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;\r\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;\r\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;\r\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;\r\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;\r\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000001000000000;\r\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000000010000000000;\r\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000000100000000000;\r\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000001000000000000;\r\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000000010000000000000;\r\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000000100000000000000;\r\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000001000000000000000;\r\nconst TransitionLane11: Lane = /*                       */ 0b0000000000000010000000000000000;\r\nconst TransitionLane12: Lane = /*                       */ 0b0000000000000100000000000000000;\r\nconst TransitionLane13: Lane = /*                       */ 0b0000000000001000000000000000000;\r\nconst TransitionLane14: Lane = /*                       */ 0b0000000000010000000000000000000;\r\nconst TransitionLane15: Lane = /*                       */ 0b0000000000100000000000000000000;\r\nconst TransitionLane16: Lane = /*                       */ 0b0000000001000000000000000000000;\r\n\r\nconst RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;\r\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\r\nconst RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000;\r\nconst RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000;\r\nconst RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000;\r\nconst RetryLane5: Lane = /*                             */ 0b0000100000000000000000000000000;\r\n\r\nexport const SomeRetryLane: Lane = RetryLane1;\r\n\r\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;\r\n\r\nconst NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;\r\n\r\nexport const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;\r\nexport const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;\r\n\r\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;\r\n\r\n// This function is used for the experimental timeline (react-devtools-timeline)\r\n// It should be kept in sync with the Lanes values above.\r\nexport function getLabelForLane(lane: Lane): string | void {\r\n  if (enableSchedulingProfiler) {\r\n    if (lane & SyncLane) {\r\n      return 'Sync';\r\n    }\r\n    if (lane & InputContinuousHydrationLane) {\r\n      return 'InputContinuousHydration';\r\n    }\r\n    if (lane & InputContinuousLane) {\r\n      return 'InputContinuous';\r\n    }\r\n    if (lane & DefaultHydrationLane) {\r\n      return 'DefaultHydration';\r\n    }\r\n    if (lane & DefaultLane) {\r\n      return 'Default';\r\n    }\r\n    if (lane & TransitionHydrationLane) {\r\n      return 'TransitionHydration';\r\n    }\r\n    if (lane & TransitionLanes) {\r\n      return 'Transition';\r\n    }\r\n    if (lane & RetryLanes) {\r\n      return 'Retry';\r\n    }\r\n    if (lane & SelectiveHydrationLane) {\r\n      return 'SelectiveHydration';\r\n    }\r\n    if (lane & IdleHydrationLane) {\r\n      return 'IdleHydration';\r\n    }\r\n    if (lane & IdleLane) {\r\n      return 'Idle';\r\n    }\r\n    if (lane & OffscreenLane) {\r\n      return 'Offscreen';\r\n    }\r\n  }\r\n}\r\n\r\nexport const NoTimestamp = -1;\r\n\r\nlet nextTransitionLane: Lane = TransitionLane1;\r\nlet nextRetryLane: Lane = RetryLane1;\r\n\r\nfunction getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {\r\n  switch (getHighestPriorityLane(lanes)) {\r\n    case SyncLane:\r\n      return SyncLane;\r\n    case InputContinuousHydrationLane:\r\n      return InputContinuousHydrationLane;\r\n    case InputContinuousLane:\r\n      return InputContinuousLane;\r\n    case DefaultHydrationLane:\r\n      return DefaultHydrationLane;\r\n    case DefaultLane:\r\n      return DefaultLane;\r\n    case TransitionHydrationLane:\r\n      return TransitionHydrationLane;\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n      return lanes & TransitionLanes;\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      return lanes & RetryLanes;\r\n    case SelectiveHydrationLane:\r\n      return SelectiveHydrationLane;\r\n    case IdleHydrationLane:\r\n      return IdleHydrationLane;\r\n    case IdleLane:\r\n      return IdleLane;\r\n    case OffscreenLane:\r\n      return OffscreenLane;\r\n    default:\r\n      if (__DEV__) {\r\n        console.error(\r\n          'Should have found matching lanes. This is a bug in React.',\r\n        );\r\n      }\r\n      // This shouldn't be reachable, but as a fallback, return the entire bitmask.\r\n      return lanes;\r\n  }\r\n}\r\n\r\nexport function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {\r\n  // Early bailout if there's no pending work left.\r\n  const pendingLanes = root.pendingLanes;\r\n  if (pendingLanes === NoLanes) {\r\n    return NoLanes;\r\n  }\r\n\r\n  let nextLanes = NoLanes;\r\n\r\n  const suspendedLanes = root.suspendedLanes;\r\n  const pingedLanes = root.pingedLanes;\r\n\r\n  // Do not work on any idle work until all the non-idle work has finished,\r\n  // even if the work is suspended.\r\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\r\n  if (nonIdlePendingLanes !== NoLanes) {\r\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\r\n    if (nonIdleUnblockedLanes !== NoLanes) {\r\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\r\n    } else {\r\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\r\n      if (nonIdlePingedLanes !== NoLanes) {\r\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\r\n      }\r\n    }\r\n  } else {\r\n    // The only remaining work is Idle.\r\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\r\n    if (unblockedLanes !== NoLanes) {\r\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\r\n    } else {\r\n      if (pingedLanes !== NoLanes) {\r\n        nextLanes = getHighestPriorityLanes(pingedLanes);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (nextLanes === NoLanes) {\r\n    // This should only be reachable if we're suspended\r\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\r\n    return NoLanes;\r\n  }\r\n\r\n  // If we're already in the middle of a render, switching lanes will interrupt\r\n  // it and we'll lose our progress. We should only do this if the new lanes are\r\n  // higher priority.\r\n  if (\r\n    wipLanes !== NoLanes &&\r\n    wipLanes !== nextLanes &&\r\n    // If we already suspended with a delay, then interrupting is fine. Don't\r\n    // bother waiting until the root is complete.\r\n    (wipLanes & suspendedLanes) === NoLanes\r\n  ) {\r\n    const nextLane = getHighestPriorityLane(nextLanes);\r\n    const wipLane = getHighestPriorityLane(wipLanes);\r\n    if (\r\n      // Tests whether the next lane is equal or lower priority than the wip\r\n      // one. This works because the bits decrease in priority as you go left.\r\n      nextLane >= wipLane ||\r\n      // Default priority updates should not interrupt transition updates. The\r\n      // only difference between default updates and transition updates is that\r\n      // default updates do not support refresh transitions.\r\n      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)\r\n    ) {\r\n      // Keep working on the existing in-progress tree. Do not interrupt.\r\n      return wipLanes;\r\n    }\r\n  }\r\n\r\n  if (\r\n    allowConcurrentByDefault &&\r\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\r\n  ) {\r\n    // Do nothing, use the lanes as they were assigned.\r\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\r\n    // When updates are sync by default, we entangle continuous priority updates\r\n    // and default updates, so they render in the same batch. The only reason\r\n    // they use separate lanes is because continuous updates should interrupt\r\n    // transitions, but default updates should not.\r\n    nextLanes |= pendingLanes & DefaultLane;\r\n  }\r\n\r\n  // Check for entangled lanes and add them to the batch.\r\n  //\r\n  // A lane is said to be entangled with another when it's not allowed to render\r\n  // in a batch that does not also include the other lane. Typically we do this\r\n  // when multiple updates have the same source, and we only want to respond to\r\n  // the most recent event from that source.\r\n  //\r\n  // Note that we apply entanglements *after* checking for partial work above.\r\n  // This means that if a lane is entangled during an interleaved event while\r\n  // it's already rendering, we won't interrupt it. This is intentional, since\r\n  // entanglement is usually \"best effort\": we'll try our best to render the\r\n  // lanes in the same batch, but it's not worth throwing out partially\r\n  // completed work in order to do it.\r\n  // TODO: Reconsider this. The counter-argument is that the partial work\r\n  // represents an intermediate state, which we don't want to show to the user.\r\n  // And by spending extra time finishing it, we're increasing the amount of\r\n  // time it takes to show the final state, which is what they are actually\r\n  // waiting for.\r\n  //\r\n  // For those exceptions where entanglement is semantically important, like\r\n  // useMutableSource, we should ensure that there is no partial work at the\r\n  // time we apply the entanglement.\r\n  const entangledLanes = root.entangledLanes;\r\n  if (entangledLanes !== NoLanes) {\r\n    const entanglements = root.entanglements;\r\n    let lanes = nextLanes & entangledLanes;\r\n    while (lanes > 0) {\r\n      const index = pickArbitraryLaneIndex(lanes);\r\n      const lane = 1 << index;\r\n\r\n      nextLanes |= entanglements[index];\r\n\r\n      lanes &= ~lane;\r\n    }\r\n  }\r\n\r\n  return nextLanes;\r\n}\r\n\r\nexport function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {\r\n  const eventTimes = root.eventTimes;\r\n\r\n  let mostRecentEventTime = NoTimestamp;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const eventTime = eventTimes[index];\r\n    if (eventTime > mostRecentEventTime) {\r\n      mostRecentEventTime = eventTime;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n\r\n  return mostRecentEventTime;\r\n}\r\n\r\nfunction computeExpirationTime(lane: Lane, currentTime: number) {\r\n  switch (lane) {\r\n    case SyncLane:\r\n    case InputContinuousHydrationLane:\r\n    case InputContinuousLane:\r\n      // User interactions should expire slightly more quickly.\r\n      //\r\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\r\n      // When we made it larger, a product metric in www regressed, suggesting\r\n      // there's a user interaction that's being starved by a series of\r\n      // synchronous updates. If that theory is correct, the proper solution is\r\n      // to fix the starvation. However, this scenario supports the idea that\r\n      // expiration times are an important safeguard when starvation\r\n      // does happen.\r\n      return currentTime + 250;\r\n    case DefaultHydrationLane:\r\n    case DefaultLane:\r\n    case TransitionHydrationLane:\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n      return currentTime + 5000;\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      // TODO: Retries should be allowed to expire if they are CPU bound for\r\n      // too long, but when I made this change it caused a spike in browser\r\n      // crashes. There must be some other underlying bug; not super urgent but\r\n      // ideally should figure out why and fix it. Unfortunately we don't have\r\n      // a repro for the crashes, only detected via production metrics.\r\n      return NoTimestamp;\r\n    case SelectiveHydrationLane:\r\n    case IdleHydrationLane:\r\n    case IdleLane:\r\n    case OffscreenLane:\r\n      // Anything idle priority or lower should never expire.\r\n      return NoTimestamp;\r\n    default:\r\n      if (__DEV__) {\r\n        console.error(\r\n          'Should have found matching lanes. This is a bug in React.',\r\n        );\r\n      }\r\n      return NoTimestamp;\r\n  }\r\n}\r\n\r\nexport function markStarvedLanesAsExpired(\r\n  root: FiberRoot,\r\n  currentTime: number,\r\n): void {\r\n  // TODO: This gets called every time we yield. We can optimize by storing\r\n  // the earliest expiration time on the root. Then use that to quickly bail out\r\n  // of this function.\r\n\r\n  const pendingLanes = root.pendingLanes;\r\n  const suspendedLanes = root.suspendedLanes;\r\n  const pingedLanes = root.pingedLanes;\r\n  const expirationTimes = root.expirationTimes;\r\n\r\n  // Iterate through the pending lanes and check if we've reached their\r\n  // expiration time. If so, we'll assume the update is being starved and mark\r\n  // it as expired to force it to finish.\r\n  //\r\n  // We exclude retry lanes because those must always be time sliced, in order\r\n  // to unwrap uncached promises.\r\n  // TODO: Write a test for this\r\n  let lanes = pendingLanes & ~RetryLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const expirationTime = expirationTimes[index];\r\n    if (expirationTime === NoTimestamp) {\r\n      // Found a pending lane with no expiration time. If it's not suspended, or\r\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\r\n      // using the current time.\r\n      if (\r\n        (lane & suspendedLanes) === NoLanes ||\r\n        (lane & pingedLanes) !== NoLanes\r\n      ) {\r\n        // Assumes timestamps are monotonically increasing.\r\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\r\n      }\r\n    } else if (expirationTime <= currentTime) {\r\n      // This lane expired\r\n      root.expiredLanes |= lane;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\n// This returns the highest priority pending lanes regardless of whether they\r\n// are suspended.\r\nexport function getHighestPriorityPendingLanes(root: FiberRoot): Lanes {\r\n  return getHighestPriorityLanes(root.pendingLanes);\r\n}\r\n\r\nexport function getLanesToRetrySynchronouslyOnError(\r\n  root: FiberRoot,\r\n  originallyAttemptedLanes: Lanes,\r\n): Lanes {\r\n  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\r\n    // The error recovery mechanism is disabled until these lanes are cleared.\r\n    return NoLanes;\r\n  }\r\n\r\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\r\n  if (everythingButOffscreen !== NoLanes) {\r\n    return everythingButOffscreen;\r\n  }\r\n  if (everythingButOffscreen & OffscreenLane) {\r\n    return OffscreenLane;\r\n  }\r\n  return NoLanes;\r\n}\r\n\r\nexport function includesSyncLane(lanes: Lanes): boolean {\r\n  return (lanes & SyncLane) !== NoLanes;\r\n}\r\n\r\nexport function includesNonIdleWork(lanes: Lanes): boolean {\r\n  return (lanes & NonIdleLanes) !== NoLanes;\r\n}\r\nexport function includesOnlyRetries(lanes: Lanes): boolean {\r\n  return (lanes & RetryLanes) === lanes;\r\n}\r\nexport function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {\r\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\r\n  return (lanes & UrgentLanes) === NoLanes;\r\n}\r\nexport function includesOnlyTransitions(lanes: Lanes): boolean {\r\n  return (lanes & TransitionLanes) === lanes;\r\n}\r\n\r\nexport function includesBlockingLane(root: FiberRoot, lanes: Lanes): boolean {\r\n  if (\r\n    allowConcurrentByDefault &&\r\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\r\n  ) {\r\n    // Concurrent updates by default always use time slicing.\r\n    return false;\r\n  }\r\n  const SyncDefaultLanes =\r\n    InputContinuousHydrationLane |\r\n    InputContinuousLane |\r\n    DefaultHydrationLane |\r\n    DefaultLane;\r\n  return (lanes & SyncDefaultLanes) !== NoLanes;\r\n}\r\n\r\nexport function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {\r\n  // This is a separate check from includesBlockingLane because a lane can\r\n  // expire after a render has already started.\r\n  return (lanes & root.expiredLanes) !== NoLanes;\r\n}\r\n\r\nexport function isTransitionLane(lane: Lane): boolean {\r\n  return (lane & TransitionLanes) !== NoLanes;\r\n}\r\n\r\nexport function claimNextTransitionLane(): Lane {\r\n  // Cycle through the lanes, assigning each new transition to the next lane.\r\n  // In most cases, this means every transition gets its own lane, until we\r\n  // run out of lanes and cycle back to the beginning.\r\n  const lane = nextTransitionLane;\r\n  nextTransitionLane <<= 1;\r\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\r\n    nextTransitionLane = TransitionLane1;\r\n  }\r\n  return lane;\r\n}\r\n\r\nexport function claimNextRetryLane(): Lane {\r\n  const lane = nextRetryLane;\r\n  nextRetryLane <<= 1;\r\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\r\n    nextRetryLane = RetryLane1;\r\n  }\r\n  return lane;\r\n}\r\n\r\nexport function getHighestPriorityLane(lanes: Lanes): Lane {\r\n  return lanes & -lanes;\r\n}\r\n\r\nexport function pickArbitraryLane(lanes: Lanes): Lane {\r\n  // This wrapper function gets inlined. Only exists so to communicate that it\r\n  // doesn't matter which bit is selected; you can pick any bit without\r\n  // affecting the algorithms where its used. Here I'm using\r\n  // getHighestPriorityLane because it requires the fewest operations.\r\n  return getHighestPriorityLane(lanes);\r\n}\r\n\r\nfunction pickArbitraryLaneIndex(lanes: Lanes) {\r\n  return 31 - clz32(lanes);\r\n}\r\n\r\nfunction laneToIndex(lane: Lane) {\r\n  return pickArbitraryLaneIndex(lane);\r\n}\r\n\r\nexport function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {\r\n  return (a & b) !== NoLanes;\r\n}\r\n\r\nexport function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {\r\n  return (set & subset) === subset;\r\n}\r\n\r\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\r\n  return a | b;\r\n}\r\n\r\nexport function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\r\n  return set & ~subset;\r\n}\r\n\r\nexport function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\r\n  return a & b;\r\n}\r\n\r\n// Seems redundant, but it changes the type from a single lane (used for\r\n// updates) to a group of lanes (used for flushing work).\r\nexport function laneToLanes(lane: Lane): Lanes {\r\n  return lane;\r\n}\r\n\r\nexport function higherPriorityLane(a: Lane, b: Lane): Lane {\r\n  // This works because the bit ranges decrease in priority as you go left.\r\n  return a !== NoLane && a < b ? a : b;\r\n}\r\n\r\nexport function createLaneMap<T>(initial: T): LaneMap<T> {\r\n  // Intentionally pushing one by one.\r\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\r\n  const laneMap = [];\r\n  for (let i = 0; i < TotalLanes; i++) {\r\n    laneMap.push(initial);\r\n  }\r\n  return laneMap;\r\n}\r\n\r\nexport function markRootUpdated(\r\n  root: FiberRoot,\r\n  updateLane: Lane,\r\n  eventTime: number,\r\n) {\r\n  root.pendingLanes |= updateLane;\r\n\r\n  // If there are any suspended transitions, it's possible this new update\r\n  // could unblock them. Clear the suspended lanes so that we can try rendering\r\n  // them again.\r\n  //\r\n  // TODO: We really only need to unsuspend only lanes that are in the\r\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\r\n  // path. This would exclude suspended updates in an unrelated sibling tree,\r\n  // since there's no way for this update to unblock it.\r\n  //\r\n  // We don't do this if the incoming update is idle, because we never process\r\n  // idle updates until after all the regular updates have finished; there's no\r\n  // way it could unblock a transition.\r\n  if (updateLane !== IdleLane) {\r\n    root.suspendedLanes = NoLanes;\r\n    root.pingedLanes = NoLanes;\r\n  }\r\n\r\n  const eventTimes = root.eventTimes;\r\n  const index = laneToIndex(updateLane);\r\n  // We can always overwrite an existing timestamp because we prefer the most\r\n  // recent event, and we assume time is monotonically increasing.\r\n  eventTimes[index] = eventTime;\r\n}\r\n\r\nexport function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {\r\n  root.suspendedLanes |= suspendedLanes;\r\n  root.pingedLanes &= ~suspendedLanes;\r\n\r\n  // The suspended lanes are no longer CPU-bound. Clear their expiration times.\r\n  const expirationTimes = root.expirationTimes;\r\n  let lanes = suspendedLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    expirationTimes[index] = NoTimestamp;\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function markRootPinged(\r\n  root: FiberRoot,\r\n  pingedLanes: Lanes,\r\n  eventTime: number,\r\n) {\r\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\r\n}\r\n\r\nexport function markRootMutableRead(root: FiberRoot, updateLane: Lane) {\r\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\r\n}\r\n\r\nexport function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {\r\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\r\n\r\n  root.pendingLanes = remainingLanes;\r\n\r\n  // Let's try everything again\r\n  root.suspendedLanes = NoLanes;\r\n  root.pingedLanes = NoLanes;\r\n\r\n  root.expiredLanes &= remainingLanes;\r\n  root.mutableReadLanes &= remainingLanes;\r\n\r\n  root.entangledLanes &= remainingLanes;\r\n\r\n  root.errorRecoveryDisabledLanes &= remainingLanes;\r\n\r\n  const entanglements = root.entanglements;\r\n  const eventTimes = root.eventTimes;\r\n  const expirationTimes = root.expirationTimes;\r\n  const hiddenUpdates = root.hiddenUpdates;\r\n\r\n  // Clear the lanes that no longer have pending work\r\n  let lanes = noLongerPendingLanes;\r\n  while (lanes > 0) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    entanglements[index] = NoLanes;\r\n    eventTimes[index] = NoTimestamp;\r\n    expirationTimes[index] = NoTimestamp;\r\n\r\n    const hiddenUpdatesForLane = hiddenUpdates[index];\r\n    if (hiddenUpdatesForLane !== null) {\r\n      hiddenUpdates[index] = null;\r\n      // \"Hidden\" updates are updates that were made to a hidden component. They\r\n      // have special logic associated with them because they may be entangled\r\n      // with updates that occur outside that tree. But once the outer tree\r\n      // commits, they behave like regular updates.\r\n      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {\r\n        const update = hiddenUpdatesForLane[i];\r\n        if (update !== null) {\r\n          update.lane &= ~OffscreenLane;\r\n        }\r\n      }\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {\r\n  // In addition to entangling each of the given lanes with each other, we also\r\n  // have to consider _transitive_ entanglements. For each lane that is already\r\n  // entangled with *any* of the given lanes, that lane is now transitively\r\n  // entangled with *all* the given lanes.\r\n  //\r\n  // Translated: If C is entangled with A, then entangling A with B also\r\n  // entangles C with B.\r\n  //\r\n  // If this is hard to grasp, it might help to intentionally break this\r\n  // function and look at the tests that fail in ReactTransition-test.js. Try\r\n  // commenting out one of the conditions below.\r\n\r\n  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);\r\n  const entanglements = root.entanglements;\r\n  let lanes = rootEntangledLanes;\r\n  while (lanes) {\r\n    const index = pickArbitraryLaneIndex(lanes);\r\n    const lane = 1 << index;\r\n    if (\r\n      // Is this one of the newly entangled lanes?\r\n      (lane & entangledLanes) |\r\n      // Is this lane transitively entangled with the newly entangled lanes?\r\n      (entanglements[index] & entangledLanes)\r\n    ) {\r\n      entanglements[index] |= entangledLanes;\r\n    }\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function markHiddenUpdate(\r\n  root: FiberRoot,\r\n  update: ConcurrentUpdate,\r\n  lane: Lane,\r\n) {\r\n  const index = laneToIndex(lane);\r\n  const hiddenUpdates = root.hiddenUpdates;\r\n  const hiddenUpdatesForLane = hiddenUpdates[index];\r\n  if (hiddenUpdatesForLane === null) {\r\n    hiddenUpdates[index] = [update];\r\n  } else {\r\n    hiddenUpdatesForLane.push(update);\r\n  }\r\n  update.lane = lane | OffscreenLane;\r\n}\r\n\r\nexport function getBumpedLaneForHydration(\r\n  root: FiberRoot,\r\n  renderLanes: Lanes,\r\n): Lane {\r\n  const renderLane = getHighestPriorityLane(renderLanes);\r\n\r\n  let lane;\r\n  switch (renderLane) {\r\n    case InputContinuousLane:\r\n      lane = InputContinuousHydrationLane;\r\n      break;\r\n    case DefaultLane:\r\n      lane = DefaultHydrationLane;\r\n      break;\r\n    case TransitionLane1:\r\n    case TransitionLane2:\r\n    case TransitionLane3:\r\n    case TransitionLane4:\r\n    case TransitionLane5:\r\n    case TransitionLane6:\r\n    case TransitionLane7:\r\n    case TransitionLane8:\r\n    case TransitionLane9:\r\n    case TransitionLane10:\r\n    case TransitionLane11:\r\n    case TransitionLane12:\r\n    case TransitionLane13:\r\n    case TransitionLane14:\r\n    case TransitionLane15:\r\n    case TransitionLane16:\r\n    case RetryLane1:\r\n    case RetryLane2:\r\n    case RetryLane3:\r\n    case RetryLane4:\r\n    case RetryLane5:\r\n      lane = TransitionHydrationLane;\r\n      break;\r\n    case IdleLane:\r\n      lane = IdleHydrationLane;\r\n      break;\r\n    default:\r\n      // Everything else is already either a hydration lane, or shouldn't\r\n      // be retried at a hydration lane.\r\n      lane = NoLane;\r\n      break;\r\n  }\r\n\r\n  // Check if the lane we chose is suspended. If so, that indicates that we\r\n  // already attempted and failed to hydrate at that level. Also check if we're\r\n  // already rendering that lane, which is rare but could happen.\r\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\r\n    // Give up trying to hydrate and fall back to client render.\r\n    return NoLane;\r\n  }\r\n\r\n  return lane;\r\n}\r\n\r\nexport function addFiberToLanesMap(\r\n  root: FiberRoot,\r\n  fiber: Fiber,\r\n  lanes: Lanes | Lane,\r\n) {\r\n  if (!enableUpdaterTracking) {\r\n    return;\r\n  }\r\n  if (!isDevToolsPresent) {\r\n    return;\r\n  }\r\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const updaters = pendingUpdatersLaneMap[index];\r\n    updaters.add(fiber);\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {\r\n  if (!enableUpdaterTracking) {\r\n    return;\r\n  }\r\n  if (!isDevToolsPresent) {\r\n    return;\r\n  }\r\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\r\n  const memoizedUpdaters = root.memoizedUpdaters;\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const updaters = pendingUpdatersLaneMap[index];\r\n    if (updaters.size > 0) {\r\n      updaters.forEach(fiber => {\r\n        const alternate = fiber.alternate;\r\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\r\n          memoizedUpdaters.add(fiber);\r\n        }\r\n      });\r\n      updaters.clear();\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n\r\nexport function addTransitionToLanesMap(\r\n  root: FiberRoot,\r\n  transition: Transition,\r\n  lane: Lane,\r\n) {\r\n  if (enableTransitionTracing) {\r\n    const transitionLanesMap = root.transitionLanes;\r\n    const index = laneToIndex(lane);\r\n    let transitions = transitionLanesMap[index];\r\n    if (transitions === null) {\r\n      transitions = new Set();\r\n    }\r\n    transitions.add(transition);\r\n\r\n    transitionLanesMap[index] = transitions;\r\n  }\r\n}\r\n\r\nexport function getTransitionsForLanes(\r\n  root: FiberRoot,\r\n  lanes: Lane | Lanes,\r\n): Array<Transition> | null {\r\n  if (!enableTransitionTracing) {\r\n    return null;\r\n  }\r\n\r\n  const transitionsForLanes = [];\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n    const transitions = root.transitionLanes[index];\r\n    if (transitions !== null) {\r\n      transitions.forEach(transition => {\r\n        transitionsForLanes.push(transition);\r\n      });\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n\r\n  if (transitionsForLanes.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return transitionsForLanes;\r\n}\r\n\r\nexport function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {\r\n  if (!enableTransitionTracing) {\r\n    return;\r\n  }\r\n\r\n  while (lanes > 0) {\r\n    const index = laneToIndex(lanes);\r\n    const lane = 1 << index;\r\n\r\n    const transitions = root.transitionLanes[index];\r\n    if (transitions !== null) {\r\n      root.transitionLanes[index] = null;\r\n    }\r\n\r\n    lanes &= ~lane;\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type {Lane, Lanes} from './ReactFiberLane.old';\r\n\r\nimport {\r\n  NoLane,\r\n  SyncLane,\r\n  InputContinuousLane,\r\n  DefaultLane,\r\n  IdleLane,\r\n  getHighestPriorityLane,\r\n  includesNonIdleWork,\r\n} from './ReactFiberLane.old';\r\n\r\nexport opaque type EventPriority = Lane;\r\n\r\nexport const DiscreteEventPriority: EventPriority = SyncLane;\r\nexport const ContinuousEventPriority: EventPriority = InputContinuousLane;\r\nexport const DefaultEventPriority: EventPriority = DefaultLane;\r\nexport const IdleEventPriority: EventPriority = IdleLane;\r\n\r\nlet currentUpdatePriority: EventPriority = NoLane;\r\n\r\nexport function getCurrentUpdatePriority(): EventPriority {\r\n  return currentUpdatePriority;\r\n}\r\n\r\nexport function setCurrentUpdatePriority(newPriority: EventPriority) {\r\n  currentUpdatePriority = newPriority;\r\n}\r\n\r\nexport function runWithPriority<T>(priority: EventPriority, fn: () => T): T {\r\n  const previousPriority = currentUpdatePriority;\r\n  try {\r\n    currentUpdatePriority = priority;\r\n    return fn();\r\n  } finally {\r\n    currentUpdatePriority = previousPriority;\r\n  }\r\n}\r\n\r\nexport function higherEventPriority(\r\n  a: EventPriority,\r\n  b: EventPriority,\r\n): EventPriority {\r\n  return a !== 0 && a < b ? a : b;\r\n}\r\n\r\nexport function lowerEventPriority(\r\n  a: EventPriority,\r\n  b: EventPriority,\r\n): EventPriority {\r\n  return a === 0 || a > b ? a : b;\r\n}\r\n\r\nexport function isHigherEventPriority(\r\n  a: EventPriority,\r\n  b: EventPriority,\r\n): boolean {\r\n  return a !== 0 && a < b;\r\n}\r\n\r\nexport function lanesToEventPriority(lanes: Lanes): EventPriority {\r\n  const lane = getHighestPriorityLane(lanes);\r\n  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\r\n    return DiscreteEventPriority;\r\n  }\r\n  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\r\n    return ContinuousEventPriority;\r\n  }\r\n  if (includesNonIdleWork(lane)) {\r\n    return DefaultEventPriority;\r\n  }\r\n  return IdleEventPriority;\r\n}\r\n","/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nexport type RootTag = 0 | 1;\r\n\r\nexport const LegacyRoot = 0;\r\nexport const ConcurrentRoot = 1;\r\n"],"names":["SyncLane","InputContinuousLane","DefaultLane","IdleLane","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","LegacyRoot","ConcurrentRoot"],"mappings":";;AAsCO,IAAMA,QAAc;AAAG;AAA6B,CAApD;AAGA,IAAMC,mBAAyB;AAAG;AAAkB,CAApD;AAGA,IAAMC,WAAiB;AAAG;AAA0B,EAApD;AAmCA,IAAMC,QAAc;AAAG;AAA6B,SAApD;;ICxDMC,qBAAoC,GAAGJ,QAA7C;AACP,IAAaK,uBAAsC,GAAGJ,mBAA/C;AACP,IAAaK,oBAAmC,GAAGJ,WAA5C;AACP,IAAaK,iBAAgC,GAAGJ,QAAzC;;ICfMK,UAAU,GAAG,CAAnB;AACP,IAAaC,cAAc,GAAG,CAAvB;;;;;;;;;"}